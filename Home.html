<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Uphill Health - Enhanced AI Medical Intro</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Exo 2', sans-serif; /* Changed from Orbitron */
            color: white;
            background: #0a0a1f;
        }
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
        }
        .content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0;
            animation: fadeIn 1.5s ease-in-out 2.5s forwards;
        }
        .content h1 {
            font-size: 5.5em; /* Reduced from 6.5em */
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 10px; /* Adjusted for balance */
            background: linear-gradient(45deg, #00f0ff, yellow);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 60px rgba(0, 240, 255, 1);
            animation: pulseGlow 4s ease-in-out infinite;
        }
        .content p {
            font-size: 1.8em; /* Reduced from 2.1em */
            margin: 25px 0; /* Adjusted for balance */
            max-width: 900px;
            line-height: 1.6;
            color: #e0f0ff;
            text-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            opacity: 0;
            animation: slideUp 1s ease-in-out 3s forwards;
        }
        .cta-button {
            display: inline-block;
            padding: 20px 60px; /* Slightly smaller for balance */
            background: linear-gradient(45deg, #00f0ff, #00ff88);
            color: #0a0a1f;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.4em; /* Slightly smaller for balance */
            border-radius: 50px;
            transition: transform 0.3s, box-shadow 0.3s;
            box-shadow: 0 0 40px rgba(0, 240, 255, 1);
            animation: buttonPulse 2s ease-in-out infinite;
            opacity: 0;
            animation-delay: 3.5s;
            animation-fill-mode: forwards;
        }
        .cta-button:hover {
            transform: scale(1.3);
            box-shadow: 0 0 80px rgba(0, 240, 255, 1);
        }
        .medical-grid {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0, 240, 255, 0.3) 0%, transparent 70%);
            pointer-events: none;
            z-index: 0;
        }
        @keyframes fadeIn {
            0% { opacity: 0; transform: translate(-50%, -40%); }
            100% { opacity: 1; transform: translate(-50%, -50%); }
        }
        @keyframes slideUp {
            0% { opacity: 0; transform: translateY(40px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        @keyframes pulseGlow {
            0% { text-shadow: 0 0 30px rgba(0, 240, 255, 0.8); }
            50% { text-shadow: 0 0 80px rgba(0, 240, 255, 1), 0 0 90px rgba(0, 255, 136, 0.9); }
            100% { text-shadow: 0 0 30px rgba(0, 240, 255, 0.8); }
        }
        @keyframes buttonPulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.25); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="canvas-container"></div>
    <div class="medical-grid"></div>
    <div class="content">
        <h1>Uphill Health</h1>
        <p>Revolutionizing healthcare with AI-driven precision. Harnessing neural networks for advanced diagnostics and personalized wellness.</p>
        <a href="{{ url_for('home18') }}" class="cta-button">Let's Get started</a>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Holographic heart model
        const heartGroup = new THREE.Group();
        const heartGeometry = new THREE.SphereGeometry(0.7, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
        const heartMaterial = new THREE.MeshPhongMaterial({ 
            color: 0xff4444, 
            shininess: 200, 
            transparent: true, 
            opacity: 0.8 
        });
        const heart = new THREE.Mesh(heartGeometry, heartMaterial);
        heart.scale.set(1, 1.2, 1);
        heartGroup.add(heart);

        // Diagnostic overlay (glowing data points)
        const dataPointGeometry = new THREE.SphereGeometry(0.05, 8, 8);
        const dataPointMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
        const dataPoints = [];
        for (let i = 0; i < 12; i++) {
            const point = new THREE.Mesh(dataPointGeometry, dataPointMaterial);
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI / 2;
            point.position.set(
                0.8 * Math.sin(phi) * Math.cos(theta),
                0.8 * Math.sin(phi) * Math.sin(theta),
                0.8 * Math.cos(phi)
            );
            heartGroup.add(point);
            dataPoints.push(point);
        }

        // Scanning ring with pulse effect
        const scanGeometry = new THREE.TorusGeometry(0.9, 0.03, 16, 100);
        const scanMaterial = new THREE.MeshBasicMaterial({ color: 0x00f0ff });
        const scanRing = new THREE.Mesh(scanGeometry, scanMaterial);
        scanRing.rotation.x = Math.PI / 2;
        heartGroup.add(scanRing);

        scene.add(heartGroup);

        // Enhanced medical background with AI elements
        // DNA helix
        const dnaGroup = new THREE.Group();
        const helixGeometry = new THREE.SphereGeometry(0.06, 12, 12);
        const helixMaterial = new THREE.MeshBasicMaterial({ color: 0x00f0ff });
        for (let i = 0; i < 35; i++) {
            const leftNode = new THREE.Mesh(helixGeometry, helixMaterial);
            const rightNode = new THREE.Mesh(helixGeometry, helixMaterial);
            const angle = i * Math.PI / 6;
            leftNode.position.set(Math.sin(angle) * 0.7, i * 0.25 - 3.5, -7);
            rightNode.position.set(-Math.sin(angle) * 0.7, i * 0.25 - 3.5, -7);
            dnaGroup.add(leftNode, rightNode);
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(Math.sin(angle) * 0.7, i * 0.25 - 3.5, -7),
                new THREE.Vector3(-Math.sin(angle) * 0.7, i * 0.25 - 3.5, -7)
            ]);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00f0ff, transparent: true, opacity: 0.6 });
            const line = new THREE.Line(lineGeometry, lineMaterial);
            dnaGroup.add(line);
        }
        scene.add(dnaGroup);

        // EKG lines
        const ekgGroup = new THREE.Group();
        const ekgMaterial = new THREE.LineBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.8 });
        for (let i = 0; i < 4; i++) {
            const points = [];
            for (let x = -12; x <= 12; x += 0.5) {
                points.push(new THREE.Vector3(x, Math.sin(x + i) * 0.4 + (i - 1.5) * 2, -9));
            }
            const ekgGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const ekgLine = new THREE.Line(ekgGeometry, ekgMaterial);
            ekgGroup.add(ekgLine);
        }
        scene.add(ekgGroup);

        // Molecular structure
        const moleculeGroup = new THREE.Group();
        const nodeGeometry = new THREE.SphereGeometry(0.1, 12, 12);
        const nodeMaterial = new THREE.MeshBasicMaterial({ color: 0x00f0ff });
        const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x00f0ff, transparent: true, opacity: 0.5 });
        const nodes = [];
        for (let i = 0; i < 10; i++) {
            const node = new THREE.Mesh(nodeGeometry, nodeMaterial);
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            node.position.set(
                2.5 * Math.sin(phi) * Math.cos(theta),
                2.5 * Math.sin(phi) * Math.sin(theta) - 2,
                2.5 * Math.cos(phi) - 8
            );
            moleculeGroup.add(node);
            nodes.push(node.position);
        }
        for (let i = 0; i < nodes.length; i++) {
            for (let j = i + 1; j < nodes.length; j++) {
                if (nodes[i].distanceTo(nodes[j]) < 3.5) {
                    const edgeGeometry = new THREE.BufferGeometry().setFromPoints([nodes[i], nodes[j]]);
                    const edge = new THREE.Line(edgeGeometry, edgeMaterial);
                    moleculeGroup.add(edge);
                }
            }
        }
        scene.add(moleculeGroup);

        // Health data visualization
        const graphGroup = new THREE.Group();
        const graphMaterial = new THREE.LineBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.7 });
        for (let i = 0; i < 6; i++) {
            const points = [];
            for (let x = -6; x <= 6; x += 0.2) {
                points.push(new THREE.Vector3(x, Math.sin(x * 0.5 + i) * 0.6 + (i - 3) * 1.2, -8));
            }
            const graphGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const graphLine = new THREE.Line(graphGeometry, graphMaterial);
            graphGroup.add(graphLine);
        }
        scene.add(graphGroup);

        // AI neural network
        const neuralGroup = new THREE.Group();
        const neuralNodeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
        const neuralNodeMaterial = new THREE.MeshBasicMaterial({ color: 0x00f0ff });
        const neuralEdgeMaterial = new THREE.LineBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.4 });
        const neuralNodes = [];
        for (let i = 0; i < 15; i++) {
            const node = new THREE.Mesh(neuralNodeGeometry, neuralNodeMaterial);
            node.position.set(
                (Math.random() * 2 - 1) * 4,
                (Math.random() * 2 - 1) * 3 - 1,
                -10
            );
            neuralGroup.add(node);
            neuralNodes.push(node.position);
        }
        for (let i = 0; i < neuralNodes.length; i++) {
            for (let j = i + 1; j < neuralNodes.length; j++) {
                if (neuralNodes[i].distanceTo(neuralNodes[j]) < 4 && Math.random() < 0.3) {
                    const edgeGeometry = new THREE.BufferGeometry().setFromPoints([neuralNodes[i], neuralNodes[j]]);
                    const edge = new THREE.Line(edgeGeometry, neuralEdgeMaterial);
                    neuralGroup.add(edge);
                }
            }
        }
        scene.add(neuralGroup);

        // AI data streams
        const streamGroup = new THREE.Group();
        const streamMaterial = new THREE.LineBasicMaterial({ color: 0x00f0ff, transparent: true, opacity: 0.6 });
        for (let i = 0; i < 5; i++) {
            const points = [];
            for (let y = -5; y <= 5; y += 0.2) {
                points.push(new THREE.Vector3((i - 2) * 2, y, -11));
            }
            const streamGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const stream = new THREE.Line(streamGeometry, streamMaterial);
            streamGroup.add(stream);
        }
        scene.add(streamGroup);

        // Holographic AI nodes
        const aiNodeGroup = new THREE.Group();
        const aiNodeGeometry = new THREE.SphereGeometry(0.1, 12, 12);
        const aiNodeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
        const aiNodes = [];
        for (let i = 0; i < 8; i++) {
            const node = new THREE.Mesh(aiNodeGeometry, aiNodeMaterial);
            node.position.set(
                Math.sin(i * 2 * Math.PI / 8) * 3,
                0,
                Math.cos(i * 2 * Math.PI / 8) * 3 - 9
            );
            aiNodeGroup.add(node);
            aiNodes.push(node);
        }
        scene.add(aiNodeGroup);

        // Particle system with AI data points
        const particleSystems = [];
        for (let layer = 0; layer < 4; layer++) {
            const particles = layer === 0 ? 3000 : layer === 1 ? 2000 : layer === 2 ? 1000 : 500;
            const particleGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            for (let i = 0; i < particles; i++) {
                positions.push((Math.random() * 2 - 1) * (layer === 0 ? 60 : layer === 1 ? 40 : layer === 2 ? 25 : 15));
                positions.push((Math.random() * 2 - 1) * (layer === 0 ? 60 : layer === 1 ? 40 : layer === 2 ? 25 : 15));
                positions.push((Math.random() * 2 - 1) * (layer === 0 ? 60 : layer === 1 ? 40 : layer === 2 ? 25 : 15));
                colors.push(0, layer === 3 ? 1 : Math.random(), layer === 0 || layer === 1 ? 1 : 0.5);
            }
            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const particleMaterial = new THREE.PointsMaterial({ 
                size: layer === 0 ? 0.06 : layer === 1 ? 0.12 : layer === 2 ? 0.18 : 0.28, 
                vertexColors: true, 
                transparent: true, 
                opacity: layer === 0 ? 0.2 : layer === 1 ? 0.5 : layer === 2 ? 0.7 : 0.9 
            });
            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
            particleSystems.push(particleSystem);
        }

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);
        const pointLight = new THREE.PointLight(0x00f0ff, 3, 15);
        pointLight.position.set(0, 2, 6);
        scene.add(pointLight);

        // God rays effect (simulated with sprites)
        const godRayGeometry = new THREE.PlaneGeometry(2, 10);
        const godRayMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00f0ff, 
            transparent: true, 
            opacity: 0.3, 
            blending: THREE.AdditiveBlending 
        });
        const godRays = [];
        for (let i = 0; i < 3; i++) {
            const godRay = new THREE.Mesh(godRayGeometry, godRayMaterial);
            godRay.position.set(5 - i * 3, 4, -5);
            godRay.rotation.z = Math.PI / 4;
            scene.add(godRay);
            godRays.push(godRay);
        }

        // Enhanced bloom effect
        const bloomGeometry = new THREE.PlaneGeometry(1, 1);
        const bloomMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00f0ff, 
            transparent: true, 
            opacity: 0.8, 
            blending: THREE.AdditiveBlending 
        });
        const blooms = [];
        for (let i = 0; i < 4; i++) {
            const bloom = new THREE.Mesh(bloomGeometry, bloomMaterial);
            bloom.position.set(4 - i * 2, 4 - i, 4 - i * 2);
            scene.add(bloom);
            blooms.push(bloom);
        }

        // Camera intro animation
        camera.position.set(0, 2, 20);
        let introPhase = 0;
        let introTime = 0;

        // Handle window resizing
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Faster typewriter effect
        const titleElement = document.getElementById('typewriter');
        const titleText = "Uphill Health Bots";
        let titleIndex = 0;
        function typeWriter() {
            if (titleIndex < titleText.length) {
                titleElement.innerText = titleText.slice(0, titleIndex + 1);
                titleIndex++;
                setTimeout(typeWriter, 80);
            }
        }
        setTimeout(typeWriter, 1200);

        // Animation loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Animate heart model
            heartGroup.rotation.y += 0.01;
            heartGroup.position.y = Math.sin(time) * 0.3;
            scanRing.rotation.z += 0.07;
            dataPoints.forEach((point, i) => {
                point.scale.setScalar(1 + Math.sin(time * 2 + i) * 0.4);
            });

            // Medical and AI background animations
            dnaGroup.rotation.y += 0.02;
            dnaGroup.position.y = Math.sin(time * 0.5) * 0.5;
            ekgGroup.children.forEach((line, i) => {
                const positions = line.geometry.attributes.position.array;
                for (let j = 0; j < positions.length; j += 3) {
                    positions[j + 1] = Math.sin((positions[j] + time * 3) + i) * 0.4 + (i - 1.5) * 2;
                }
                line.geometry.attributes.position.needsUpdate = true;
            });
            moleculeGroup.rotation.y += 0.015;
            moleculeGroup.rotation.x += 0.01;
            graphGroup.children.forEach((line, i) => {
                const positions = line.geometry.attributes.position.array;
                for (let j = 0; j < positions.length; j += 3) {
                    positions[j + 1] = Math.sin((positions[j] * 0.5 + time * 2) + i) * 0.6 + (i - 3) * 1.2;
                }
                line.geometry.attributes.position.needsUpdate = true;
            });
            neuralGroup.children.forEach((node, i) => {
                if (node.isMesh) {
                    node.scale.setScalar(1 + Math.sin(time + i) * 0.3);
                }
            });
            streamGroup.children.forEach((stream, i) => {
                const positions = stream.geometry.attributes.position.array;
                for (let j = 1; j < positions.length; j += 3) {
                    positions[j] += 0.1;
                    if (positions[j] > 5) positions[j] = -5;
                }
                stream.geometry.attributes.position.needsUpdate = true;
            });
            aiNodes.forEach((node, i) => {
                const angle = time + i * 2 * Math.PI / 8;
                node.position.set(
                    Math.sin(angle) * 3,
                    Math.sin(time + i) * 0.5,
                    Math.cos(angle) * 3 - 9
                );
                node.scale.setScalar(1 + Math.sin(time * 2 + i) * 0.3);
            });

            // Particle animation
            particleSystems.forEach((system, layer) => {
                const positions = system.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                    positions[i + 1] += Math.sin(time + positions[i]) * (layer === 0 ? 0.002 : layer === 1 ? 0.005 : layer === 2 ? 0.008 : 0.012);
                    if (positions[i + 1] > (layer === 0 ? 60 : layer === 1 ? 40 : layer === 2 ? 25 : 15)) {
                        positions[i + 1] = -(layer === 0 ? 60 : layer === 1 ? 40 : layer === 2 ? 25 : 15);
                    }
                }
                system.geometry.attributes.position.needsUpdate = true;
            });

            // God rays and bloom animation
            godRays.forEach((ray, i) => {
                ray.scale.setScalar(1 + Math.sin(time + i) * 0.2);
                ray.position.y = 4 + Math.sin(time * 0.5 + i) * 0.5;
            });
            blooms.forEach((bloom, i) => {
                bloom.scale.setScalar(1 + Math.sin(time * (3 + i)) * 0.6);
            });

            // Camera intro sequence
            if (introPhase === 0) {
                introTime += 0.02;
                camera.position.z = 20 - introTime * 8;
                camera.position.y = 2 + Math.sin(introTime * 2) * 0.8;
                if (camera.position.z <= 7) introPhase = 1;
            } else {
                camera.position.x = Math.sin(time * 0.15) * 6;
                camera.position.z = Math.cos(time * 0.15) * 6;
                camera.position.y = 1.7 + Math.sin(time * 0.25) * 0.9;
            }
            camera.lookAt(0, 0.7, 0);

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>